@startuml
'https://plantuml.com/class-diagram

class Main
{
    + main(String[] args)
}
Main ..> Partie : <<uses>>
Main ..> Controller : <<uses>>
Main ..> AffichagePartie : <<uses>>

package model
{
    class Partie implements ObserverJoueur
    {
        - tour : Integer

        + <<create>> Partie()
        + lancerPartie()
        - tourDeJeu()
        + tourneTuile()
        + placementTuile(dir : Direction, ligne : Integer)
        + deplacementJoueur(dir : Direction)

        - notifyRotation()
    }
    Partie ..> Direction : <<uses>>

    class Plateau
    {
        + <<create>> Plateau()
        + placementTuile(tuile : Tuile, dir : Direction, ligne : Integer) : Tuile
        + getJoueurSuivant(joueur : Joueur) : Joueur
        + getPositionsJoueurs() : Integer[]
        + finTour(joueur : Joueur)

        - notifyDisposition()
        - notifyRecupTresor()
    }
    Plateau ..> Direction : <<uses>>
    Plateau ..> TuileFactory : <<uses>>

    enum Direction
    {
        NORD
        EST
        SUD
        OUEST
    }

    class TuileFactory
    {
        + {static} makeTuileDefault(dirs : Direction[]) : TuileDefault
        + {static} makeTuileTresor(dirs : Direction[], tresor : Tresor) : TuileTresor
        + {static} makeTuileBase(dirs : Direction[], joueur : Joueur) : TuileBase
    }
    TuileFactory ..> TuileDefault : <<uses>>
    TuileFactory ..> TuileTresor : <<uses>>
    TuileFactory ..> TuileDepart : <<uses>>
    TuileFactory ..> Direction : <<uses>>

    abstract class Tuile
    {
        - m_nord : Boolean
        - m_est : Boolean
        - m_sud : Boolean
        - m_ouest : Boolean

        # <<create>> Tuile(ouvertures : Direction[])
        + deplacementEstValide(dest : Tuile, dir : Direction) : Boolean
        + rotation()
        - estOuvert(dir : Directions) : Boolean
        + {abstract} action(joueur : Joueur)
    }
    Tuile ..> Direction : <<uses>>
    Tuile ..> Joueur : <<uses>>

    class TuileDefault extends Tuile
    {
        + <<create>> TuileDefault(ouvertures : Direction[])
        + action(joueur : Joueur)
    }
    /'
    TuileDefault ..> Direction : <<uses>>
    TuileDefault ..> Joueur : <<uses>>'/

    class TuileDepart extends Tuile
    {
        + <<create>> TuileDepart(ouvertures : Direction[], joueur : Joueur)
        + action(joueur : Joueur)
    }
    /'
    TuileDepart ..> Direction : <<uses>>
    TuileDepart ..> Joueur : <<uses>> '/

    class TuileTresor extends Tuile
    {
        + <<create>> TuileTresor(ouvertures : Direction[], tresor : Tresor)
        + action(joueur : Joueur)
    }
    /'
    TuileTresor ..> Direction : <<uses>>
    TuileTresor ..> Joueur : <<uses>>
    TuileTresor ..> Tresor : <<uses>>'/

    class Joueur
    {
        - m_nom : String
        - m_couleur : Color
        - m_x : Integer
        - m_y : Integer
        - m_aFini : boolean

        + <<create>> Joueur()
        + getPosition() : Integer[]
        + getObjectif() : Tresor
        + deplacement(dir : Direction)
        + validerObjectif(tresor : Tresor)
        + caseDepart()

        - notifyPosition()
        - notifyTresorSuivant()
        - notifyVictoire()
    }
    Joueur ..> Direction : <<uses>>
    'Joueur ..> Tresor : <<uses>>

    enum Tresor
    {
        COFFRE
        CHOUETTE
        FANTOME
        BAGUE
        CHANDELIER
        LEZARD
        EPEE
        CAUVE_SOURIS
        RAT
        CARTE
        PRINCESSE
        DRAGON
        CRANE
        CLES
        GNOME
        COURONNE
        SCARABE
        SAC
        LIVRE
        COLLIER
        ARRAIGNEE
        DIAMANT
        ARMURE
        PAPILLON

        - <<create>> Tresor(nom : String)
        - m_nom
        + getNom() : String
    }

    interface ObserverJoueur
    {
        + {abstract} updatePosition(x : Integer, y : Integer)
        + {abstract} updateTresorSuivant(tresor : Tresor, tRestans : Integer)
        + {abstract} updateVictoire(nom : String)
    }

    interface ObserverPlateau
    {
        + {abstract} updateDisposition(tuiles : Tuile[])
        + {abstract} updateRecupTresor(x : Integer, y : Integer)
    }

    interface ObserverPartie
    {
        + {abstract} updateRotation()
        + {abstract} updatePositions()
    }
}

package view
{
    class AffichagePartie implements ObserverPartie, ObserverPlateau
    {

    }
}

package controller
{
    class Controller
    {

    }
}

Partie "1" *---> "1\n - m_plateau" Plateau : possède
Partie "1" *---> "1\n - m_tuileRab" Tuile : a en réserve
Partie "1" o---> "1\n - m_joueurEnCours" Joueur : au tour de
Partie "1" o---> "*\n - m_observeurs" ObserverPartie : est observé par

Plateau "1" o---> "49\n - m_tuiles" Tuile : est composé de
Plateau "1" *---> "4\n - m_joueurs" Joueur : est parcouru par
Plateau "1" o---> "*\n - m_observeurs" ObserverPlateau : est observé par

TuileTresor "1" *---> "1\n - m_tresor" Tresor : possede
TuileDepart "1" o---> "1\n - m_joueur" Joueur : Spawn sur

Joueur "1" *---> "0..6\n - m_objectif" Tresor : doit atteindre
Joueur "1" o---> "*\n - m_observeurs" ObserverJoueur : est observé par

@enduml